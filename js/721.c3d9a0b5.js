"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[721],{1721:function(n,e,t){t.r(e),t.d(e,{default:function(){return k}});var o=t(641),i=t(33),c=t(953),u=t(8848),r=t.n(u);const m={class:"problem-detail"},l={key:0},a="\n/*\n  Method 1: Recursive\n  Time complexity O(2^n) \n  Space complexity O(n)\n*/\nconst getFibonacciRecursive = (num: number): number => {\n    if (num === 0 || num === 1) return num; // 不要寫成 if (num === 0 || 1) return num;\n    return getFibonacciRecursive(num - 1) + getFibonacciRecursive(num - 2);\n};\n\n/*\n  Method 2: Iterative \n  Time complexity O(n) \n  Space complexity O(1)\n*/\nconst getFibonacciIterative = (num: number): number => {\n  if (num <= 1) return num;\n\n  let previous = 0, current = 1;\n  let next = 0;\n\n  for (let i = 2; i <= num; i++) {\n    next = previous + current;\n    previous = current;\n    current = next;\n  }\n\n  return current;\n\n/*\n  Method 3: Memoization (Dynamic Programming: Bottom-Up)\n  Time complexity O(n)\n  Space complexity O(n)\n*/\nconst getFibonacciBottomUp = (num: number): number => {\n  if (num <= 1) return num;\n  const dp: number[] = [0, 1];\n  for (let i = 2; i <= num; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[num];\n};\n\n/*\n  Method 4: Memoization (Dynamic Programming: Top-Down)\n  Time complexity O(n)\n  Space complexity O(n)\n*/\nconst getFibonacciTopDown = (num: number): number => {\n  // const memo: number[] = Array.from({ length: num + 1 }, () => -1);\n  const memo: number[] = Array(num + 1).fill(-1);\n  const helper = (n: number): number => {\n    if (n <= 1) return n;\n    if (memo[n] !== -1) return memo[n];\n    memo[n] = helper(n - 1) + helper(n - 2);\n    return memo[n];\n  };\n  return helper(num);\n};\n\n",s="\nconsole.log(getFibonacciRecursive(4)); // Output: 3\nconsole.log(getFibonacciIterative(4)); // Output: 3\nconsole.log(getFibonacciBottomUp(4)); // Output: 3\nconsole.log(getFibonacciTopDown(4)); // Output: 3\n";var p=(0,o.pM)({__name:"FibonacciSequences",setup(n){(0,o.sV)((()=>{r().highlightAll()}));const e=(0,c.KR)(!1),t=()=>{e.value=!e.value};return(n,c)=>((0,o.uX)(),(0,o.CE)("div",m,[(0,o.Lk)("button",{class:"close-btn",onClick:c[0]||(c[0]=e=>n.$emit("close"))},"×"),c[6]||(c[6]=(0,o.Lk)("h2",null,"Fibonacci Sequences",-1)),c[7]||(c[7]=(0,o.Lk)("a",{href:"https://en.wikipedia.org/wiki/Fibonacci_sequence",target:"_blank"}," https://en.wikipedia.org/wiki/Fibonacci_sequence ",-1)),c[8]||(c[8]=(0,o.Lk)("p",null,[(0,o.Lk)("strong",null,"問題:"),(0,o.eW)(" 費氏數列是一個數列，其中每個數字都是前兩個數字的和。 ")],-1)),e.value?((0,o.uX)(),(0,o.CE)("div",l,c[1]||(c[1]=[(0,o.Lk)("p",null," 數列的起始值通常為 0 和 1，因此費氏數列的前幾個數字為： 0, 1, 1, 2, 3, 5, 8, 13, 21, ...。 ",-1),(0,o.Lk)("p",null,"撰寫一個函式，接收一個整數 n，並返回費氏數列中第 n 個數字。",-1)]))):(0,o.Q3)("",!0),(0,o.Lk)("button",{id:"toggleShowMoreButton",onClick:t},(0,i.v_)(e.value?"(Hide)":"Click to Show More ↓"),1),c[9]||(c[9]=(0,o.Lk)("h3",null,"-- 我的解答 --",-1)),(0,o.Lk)("pre",{class:"code-block"},[c[2]||(c[2]=(0,o.eW)("      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,i.v_)(a)),c[3]||(c[3]=(0,o.eW)("\n    "))]),c[10]||(c[10]=(0,o.Lk)("h3",null,"-- 測試用例 --",-1)),(0,o.Lk)("pre",{class:"code-block"},[c[4]||(c[4]=(0,o.eW)("      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,i.v_)(s)),c[5]||(c[5]=(0,o.eW)("\n    "))])]))}}),b=t(6262);const g=(0,b.A)(p,[["__scopeId","data-v-201e06f3"]]);var k=g}}]);
//# sourceMappingURL=721.c3d9a0b5.js.map