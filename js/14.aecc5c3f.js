"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[14],{364:function(e,n,t){t.r(n),t.d(n,{default:function(){return S}});var o=t(641),r=t(33),a=t(3751),s=t(953),i=t(8848),u=t.n(i),l=t.p+"img/BFSAndDFS.36880746.png";const c={class:"problem-detail"},d={key:0},h={class:"modal-content"},g={key:0,class:"loading-spinner"},k=["src"],v='\n/* \n  模仿 API 資料串接\n  fetchNeighbours(1).then((data) => {console.log(data);}).catch((error) => {console.error(error);});\n  -> Output; [ 2, 3, 4 ]\n*/\nconst fakeData: Record<string, number[]> = {\n    "1": [2, 3, 4],\n    "2": [1, 5],\n    "3": [1, 5],\n    "4": [1, 6],\n    "5": [2, 3, 7],\n    "6": [4, 7],\n    "7": [5, 6],\n};\n\nasync function fetchNeighbours(node: number): Promise<number[]> {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(fakeData[node] || []); // Return an empty array if the node doesn\'t exist\n        }, 500); // Simulate network delay\n    });\n}\n\n/*\n  Assuming the graph has V vertices and E edges:\n  Time complexity: O(V + E)\n  Space complexity: O(V)\n*/\n\n// BFS 遍歷函數\nconst BFS = async (start: number) => {\n    const queue = [start];\n    const visited = new Set<number>();\n    visited.add(start);\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        if (currentNode !== undefined) {\n            console.log(currentNode);\n\n            const neighbours = await fetchNeighbours(currentNode);\n\n            for (const neighbour of neighbours) {\n                if (!visited.has(neighbour)) {\n                    queue.push(neighbour);\n                    visited.add(neighbour);\n                }\n            }\n            /* FP:\n              neighbours.forEach(neighbour => {\n                  if (!visited.has(neighbour)) {\n                      visited.add(neighbour);\n                      queue.push(neighbour);\n                  }\n              });\n            */\n        }\n    }\n};\n\n// DFS 遍歷函數\nconst DFS = async (start: number) => {\n    const stack = [start];\n    const visited = new Set<number>();\n    visited.add(start);\n\n    while (stack.length > 0) {\n        const currentNode = stack.pop();\n        console.log(currentNode);\n\n        const neighbours = await fetchNeighbours(currentNode);\n        for (let neighbour of neighbours) {\n            if (!visited.has(neighbour)) {\n                visited.add(neighbour);\n                stack.push(neighbour);\n            }\n        }\n    }\n};\n\n/* 若含失敗率的方式: Fetch API 要配合 try-catch */\nasync function fetchNodeNeighborsWithFailure(node) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (!(node in simulatedData)) {\n                reject(new Error("The specified node does not exist in the dataset"));\n            } else if (Math.random() < 0.2) {\n                reject(new Error("A random error occurred while fetching the node data"));\n            } else {\n                resolve(simulatedData[node] || []);\n            }\n        }, 500);\n    });\n}\n',b="\n\nBFS(1); // 測試 BFS 從節點 1 開始 Output: 1, 2, 3, 4, 5, 6, 7\nDFS(1); // 測試 BFS 從節點 1 開始 Output: 1, 4, 6, 7, 5, 3, 2";var p=(0,o.pM)({__name:"BFSAndDFS",setup(e){(0,o.sV)((()=>{u().highlightAll()}));const n=(0,s.KR)(!1),t=(0,s.KR)(!1),i=(0,s.KR)(!1),p=(0,s.KR)(""),f=()=>{n.value=!n.value},m=()=>{t.value=!1,i.value=!1,p.value=""},S=()=>{i.value=!1},F=()=>{i.value=!1,p.value="https://via.placeholder.com/600x400?text=Image+Not+Found"},w=()=>{t.value=!0,i.value=!0,p.value=l};return(e,s)=>((0,o.uX)(),(0,o.CE)("div",c,[(0,o.Lk)("button",{class:"close-btn",onClick:s[0]||(s[0]=n=>e.$emit("close"))},"×"),s[6]||(s[6]=(0,o.Lk)("h2",null,"BFS / DFS",-1)),s[7]||(s[7]=(0,o.Lk)("a",{href:"https://en.wikipedia.org/wiki/Breadth-first_search",target:"_blank"}," (wiki - BFS) ",-1)),s[8]||(s[8]=(0,o.Lk)("a",{href:"https://en.wikipedia.org/wiki/Depth-first_search",target:"_blank"}," (wiki - DFS) ",-1)),s[9]||(s[9]=(0,o.Lk)("p",null,[(0,o.Lk)("strong",null,"問題:"),(0,o.eW)(" Graph Traversal: 廣度優先 (Breadth-First Search, BFS) 與深度優先 (Depth-First Search, DFS) ")],-1)),n.value?((0,o.uX)(),(0,o.CE)("div",d,s[1]||(s[1]=[(0,o.Lk)("p",null," 根據節點圖，從節點 1 開始，以兩種走訪方式印出節點。 ",-1)]))):(0,o.Q3)("",!0),(0,o.Lk)("button",{id:"toggleShowMoreButton",onClick:f},(0,r.v_)(n.value?"(Hide)":"Click to Show More ↓"),1),s[10]||(s[10]=(0,o.Lk)("br",null,null,-1)),(0,o.Lk)("button",{id:"showModalButton",onClick:w},"節點圖"),s[11]||(s[11]=(0,o.Lk)("h3",null,"-- 我的解答 --",-1)),(0,o.Lk)("pre",{class:"code-block"},[s[2]||(s[2]=(0,o.eW)("      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,r.v_)(v)),s[3]||(s[3]=(0,o.eW)("\n    "))]),s[12]||(s[12]=(0,o.Lk)("h3",null,"-- 測試用例 --",-1)),(0,o.Lk)("pre",{class:"test-block"},[s[4]||(s[4]=(0,o.eW)("      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,r.v_)(b)),s[5]||(s[5]=(0,o.eW)("\n    "))]),t.value?((0,o.uX)(),(0,o.CE)("div",{key:1,class:"modal-overlay",onClick:(0,a.D$)(m,["self"])},[(0,o.Lk)("div",h,[i.value?((0,o.uX)(),(0,o.CE)("div",g,"Loading...")):(0,o.Q3)("",!0),(0,o.bo)((0,o.Lk)("img",{src:p.value,alt:"node-picture",onLoad:S,onError:F},null,40,k),[[a.aG,!i.value]]),(0,o.Lk)("button",{class:"close-button",onClick:m},"Close")])])):(0,o.Q3)("",!0)]))}}),f=t(6262);const m=(0,f.A)(p,[["__scopeId","data-v-8f0c2ff0"]]);var S=m}}]);
//# sourceMappingURL=14.aecc5c3f.js.map