"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[405],{8405:function(r,n,t){t.r(n),t.d(n,{default:function(){return b}});var e=t(641),a=t(33),i=t(953),o=t(8848),s=t.n(o);const c={class:"problem-detail"},l={key:0},u="\n/*\n  Quick Sort: moves smaller elements to left of a pivot. recursively divide array in 2 partitions\n  Time complexity: \n    - Best case: O(nlog(n))\n    - Average case: O(nlog(n))\n    - Worst case: O(n^2)\n  Space complexity: O(log(n))\n*/\nclass QuickSort {\n    static quicksort(arr: number[], start: number, end: number): void {\n        if (end <= start) return; // base case\n        const pivot = QuickSort.partition(arr, start, end);\n        QuickSort.quicksort(arr, start, pivot - 1);\n        QuickSort.quicksort(arr, pivot + 1, end);\n    }\n\n    private static partition(arr: number[], start: number, end: number): number {\n        const pivot = arr[end];\n        let i = start - 1;\n\n        for (let j = start; j <= end - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                // Swap arr[i] and arr[j]\n                [arr[i], arr[j]] = [arr[j], arr[i]];\n            }\n        }\n        i++;\n        // Swap arr[i] and arr[end] (the pivot)\n        [arr[i], arr[end]] = [arr[end], arr[i]];\n        return i; // pivot index\n    }\n}\n",k='\nconst array = [8, 2, 5, 3, 9, 4, 7, 6, 1];\nQuickSort.quicksort(array, 0, array.length - 1);\nconsole.log(array.join(" ")); // Output: 1 2 3 4 5 6 7 8 9';var p=(0,e.pM)({__name:"QuickSort",setup(r){(0,e.sV)((()=>{s().highlightAll()}));const n=(0,i.KR)(!1),t=()=>{n.value=!n.value};return(r,i)=>((0,e.uX)(),(0,e.CE)("div",c,[(0,e.Lk)("button",{class:"close-btn",onClick:i[0]||(i[0]=n=>r.$emit("close"))},"×"),i[6]||(i[6]=(0,e.Lk)("h2",null,"Quick Sort",-1)),i[7]||(i[7]=(0,e.Lk)("a",{href:"https://en.wikipedia.org/wiki/Quicksort",target:"_blank"}," wiki - Quick Sort ",-1)),i[8]||(i[8]=(0,e.Lk)("p",null,[(0,e.Lk)("strong",null,"問題:"),(0,e.eW)(" 給定一個由數字組成的陣列，使用 Quick Sort 演算法將陣列中的元素排序為遞增順序。 ")],-1)),n.value?((0,e.uX)(),(0,e.CE)("div",l,i[1]||(i[1]=[(0,e.Lk)("p",null," 如果陣列的長度為零或一，則它已經是排序好的，無需進一步操作。否則，將陣列分割為兩個子陣列： 一個包含所有小於基準點 (pivot) 的元素，另一個包含所有大於基準點的元素。對這兩個子陣列遞迴執行 Quick Sort，最後將排序結果合併為完整的排序陣列。 ",-1)]))):(0,e.Q3)("",!0),(0,e.Lk)("button",{id:"toggleShowMoreButton",onClick:t},(0,a.v_)(n.value?"(Hide)":"Click to Show More ↓"),1),i[9]||(i[9]=(0,e.Lk)("h3",null,"-- 我的解答 --",-1)),(0,e.Lk)("pre",{class:"code-block"},[i[2]||(i[2]=(0,e.eW)("      ")),(0,e.Lk)("code",{class:"language-javascript"},(0,a.v_)(u)),i[3]||(i[3]=(0,e.eW)("\n    "))]),i[10]||(i[10]=(0,e.Lk)("h3",null,"-- 測試用例 --",-1)),(0,e.Lk)("pre",{class:"test-block"},[i[4]||(i[4]=(0,e.eW)("      ")),(0,e.Lk)("code",{class:"language-javascript"},(0,a.v_)(k)),i[5]||(i[5]=(0,e.eW)("\n    "))])]))}}),d=t(6262);const v=(0,d.A)(p,[["__scopeId","data-v-4ddcbb60"]]);var b=v}}]);
//# sourceMappingURL=405.42c0089b.js.map