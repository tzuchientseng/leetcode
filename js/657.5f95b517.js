"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[657],{4657:function(n,e,t){t.r(e),t.d(e,{default:function(){return b}});var a=t(641),s=t(33),r=t(953),c=t(8848),o=t.n(c);const l={class:"problem-detail"},h={class:"code-block"},i="\n/*\n    Time complexity: O(n) - Here, n is the length of the string s.\n    Space complexity: O(min(m, n)) - Here, m is the size of the character set, and n is the length of the string s.\n*/\n\nconst lengthOfLongestSubstring = (str: string): number => {\n    const n: number = str.length;\n    let maxLength = 0;\n\n    // Map to store the most recent index of each character (Map -> [X: str[index], Y: index])\n    const charIndexMap = new Map<string, number>();\n\n    // \"start\" is the beginning of the current substring\n    for (let end = 0, start = 0; end < n; end++) {\n        if (charIndexMap.has(str[end])) {\n            // Move \"start\" to the right of the last occurrence of the character\n            start = Math.max(charIndexMap.get(str[end])! + 1, start);\n        }\n\n        // Update the maximum length of the substring\n        maxLength = Math.max(maxLength, end - start + 1);\n\n        // Record the current index of the character\n        charIndexMap.set(str[end], end);\n    }\n\n    return maxLength;\n};\n\n/* Explain:\n  例如: str = \"abcabcbb\";\n  初始: start = 0, ans = 0, charIndexMap = {}\n\n  遍歷 'a' (index 0):\n  - charIndexMap = {'a': 0}\n  - ans = 1\n  - start 仍是 0\n\n  遍歷 'b' (index 1):\n  - charIndexMap = {'a': 0, 'b': 1}\n  - ans = 2\n  - start 仍是 0\n\n  遍歷 'c' (index 2):\n  - charIndexMap = {'a': 0, 'b': 1, 'c': 2}\n  - ans = 3\n  - start 仍是 0\n\n  遍歷第二個 'a' (index 3):\n  - 發現 'a' 已存在\n  - charIndexMap.get('a') 是 0\n  - charIndexMap.get('a')! + 1 是 1\n  - start 變成 Max(1, 0) = 1\n  - ans 變成 3\n  - charIndexMap 更新為 {'a': 3, 'b': 1, 'c': 2}\n*/\n",d='\nconsole.log(lengthOfLongestSubstring("abcabcbb")); // Output: 3\nconsole.log(lengthOfLongestSubstring("bbbbb")); // Output: 1';var g=(0,a.pM)({__name:"LongestSubstring",setup(n){(0,a.sV)((()=>{o().highlightAll()}));const e=(0,r.KR)("Copy"),t=async()=>{try{await navigator.clipboard.writeText(i),e.value="Copied!",setTimeout((()=>{e.value="Copy"}),1500)}catch(n){console.error("Failed to copy: ",n)}};return(n,r)=>((0,a.uX)(),(0,a.CE)("div",l,[(0,a.Lk)("button",{class:"close-btn",onClick:r[0]||(r[0]=e=>n.$emit("close"))},"×"),r[6]||(r[6]=(0,a.Lk)("h2",null,"3_Longest Substring (medium)",-1)),r[7]||(r[7]=(0,a.Lk)("a",{href:"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/",target:"_blank"}," leetcode_3 ",-1)),r[8]||(r[8]=(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"問題:"),(0,a.eW)(" 找出最長無重複字符的子字串 給定一個字串 str，找出其中不包含重複字符的最長子字串的長度。 ")],-1)),r[9]||(r[9]=(0,a.Lk)("h3",null,"-- 我的解答 --",-1)),(0,a.Lk)("pre",h,[r[1]||(r[1]=(0,a.eW)("      ")),(0,a.Lk)("button",{class:"copy-btn",onClick:t},(0,s.v_)(e.value),1),r[2]||(r[2]=(0,a.eW)("\n      ")),(0,a.Lk)("code",{class:"language-javascript"},(0,s.v_)(i)),r[3]||(r[3]=(0,a.eW)("\n    "))]),r[10]||(r[10]=(0,a.Lk)("h3",null,"-- 測試用例 --",-1)),(0,a.Lk)("pre",{class:"test-block"},[r[4]||(r[4]=(0,a.eW)("      ")),(0,a.Lk)("code",{class:"language-javascript"},(0,s.v_)(d)),r[5]||(r[5]=(0,a.eW)("\n    "))])]))}}),u=t(6262);const p=(0,u.A)(g,[["__scopeId","data-v-00c8ceaa"]]);var b=p}}]);
//# sourceMappingURL=657.5f95b517.js.map