"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[347],{347:function(e,n,i){i.r(n),i.d(n,{default:function(){return v}});var t=i(641),r=i(33),a=i(953),l=i(8848),h=i.n(l);const p={class:"problem-detail"},o={key:0},u={class:"code-block"},s="\n/*\n  Time complexity:\n  Space complexity:\n*/\nclass PriorityQueue<T> {\n    private heap: { value: T; priority: number }[];\n\n    constructor() {\n        this.heap = [];\n    }\n\n    // 取得父節點索引\n    private getParentIndex(index: number): number {\n        return Math.floor((index - 1) / 2);\n    }\n\n    // 取得左子節點索引\n    private getLeftChildIndex(index: number): number {\n        return 2 * index + 1;\n    }\n\n    // 取得右子節點索引\n    private getRightChildIndex(index: number): number {\n        return 2 * index + 2;\n    }\n\n    // 交換兩個元素\n    private swap(i: number, j: number): void {\n        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    }\n\n    // 插入新元素\n    enqueue(value: T, priority: number): void {\n        const newNode = { value, priority };\n        this.heap.push(newNode);\n        this.heapifyUp();\n    }\n\n    // 重新排列堆（上浮操作）\n    private heapifyUp(): void {\n        let index = this.heap.length - 1;\n        while (index > 0) {\n            const parentIndex = this.getParentIndex(index);\n            if (this.heap[parentIndex].priority <= this.heap[index].priority) {\n                break;\n            }\n            this.swap(index, parentIndex);\n            index = parentIndex;\n        }\n    }\n\n    // 移除並返回優先級最高的元素（最小的）\n    dequeue(): T | null {\n        if (this.heap.length === 0) return null;\n        if (this.heap.length === 1) return this.heap.pop()!.value;\n\n        const root = this.heap[0].value;\n        this.heap[0] = this.heap.pop()!;\n        this.heapifyDown();\n        return root;\n    }\n\n    // 重新排列堆（下沉操作）\n    private heapifyDown(): void {\n        let index = 0;\n        while (this.getLeftChildIndex(index) < this.heap.length) {\n            let smallerChildIndex = this.getLeftChildIndex(index);\n            let rightChildIndex = this.getRightChildIndex(index);\n\n            if (\n                rightChildIndex < this.heap.length &&\n                this.heap[rightChildIndex].priority < this.heap[smallerChildIndex].priority\n            ) {\n                smallerChildIndex = rightChildIndex;\n            }\n\n            if (this.heap[index].priority <= this.heap[smallerChildIndex].priority) {\n                break;\n            }\n\n            this.swap(index, smallerChildIndex);\n            index = smallerChildIndex;\n        }\n    }\n\n    // 查看隊列頂部元素（不刪除）\n    peek(): T | null {\n        return this.heap.length > 0 ? this.heap[0].value : null;\n    }\n\n    // 確認是否為空\n    isEmpty(): boolean {\n        return this.heap.length === 0;\n    }\n}\n",d='\nconst pq = new PriorityQueue<string>();\n\npq.enqueue("Task 1", 3);\npq.enqueue("Task 2", 1);\npq.enqueue("Task 3", 2);\n\nconsole.log(pq.dequeue()); // "Task 2" (priority 1)\nconsole.log(pq.dequeue()); // "Task 3" (priority 2)\nconsole.log(pq.dequeue()); // "Task 1" (priority 3)\nconsole.log(pq.isEmpty()); // true\n\n-> 解釋\nenqueue(value, priority): 插入一個元素，並確保它的位置符合最小堆的性質（小的優先）。\ndequeue(): 取出 最小優先級 的元素（即優先級數值最小）。\nheapifyUp(): 當新元素加入時，上浮以保持堆的結構。\nheapifyDown(): 當 dequeue() 取出根節點後，將最後一個元素移至根部並向下調整。';var c=(0,t.pM)({__name:"PriorityQueue",setup(e){(0,t.sV)((()=>{h().highlightAll()}));const n=(0,a.KR)(!1),i=(0,a.KR)("Copy"),l=()=>{n.value=!n.value},c=async()=>{try{await navigator.clipboard.writeText(s),i.value="Copied!",setTimeout((()=>{i.value="Copy"}),1500)}catch(e){console.error("Failed to copy: ",e)}};return(e,a)=>((0,t.uX)(),(0,t.CE)("div",p,[(0,t.Lk)("button",{class:"close-btn",onClick:a[0]||(a[0]=n=>e.$emit("close"))},"×"),a[7]||(a[7]=(0,t.Lk)("h2",null,"Priority Queue",-1)),a[8]||(a[8]=(0,t.Lk)("a",{href:"https://en.wikipedia.org/wiki/Priority_queue",target:"_blank"}," wiki - Prioriy Queue ",-1)),a[9]||(a[9]=(0,t.Lk)("p",null,[(0,t.Lk)("strong",null,"問題:"),(0,t.eW)(" 特殊的隊列結構中，每個元素都有一個關聯的「優先級」，並且元素根據其優先級進行排序。 ")],-1)),n.value?((0,t.uX)(),(0,t.CE)("div",o,a[1]||(a[1]=[(0,t.Lk)("p",null," ... 我們可以用 最小堆（Min Heap） 或 最大堆（Max Heap） 來實現優先隊列。這裡我們使用 最小堆（Min Heap） 來確保優先級數值較小的元素優先出列。 通常，優先級高的元素會被優先處理。 ",-1)]))):(0,t.Q3)("",!0),(0,t.Lk)("button",{id:"toggleShowMoreButton",onClick:l},(0,r.v_)(n.value?"(Hide)":"Click to Show More ↓"),1),a[10]||(a[10]=(0,t.Lk)("h3",null,"-- 我的解答 --",-1)),(0,t.Lk)("pre",u,[a[2]||(a[2]=(0,t.eW)("      ")),(0,t.Lk)("button",{class:"copy-btn",onClick:c},(0,r.v_)(i.value),1),a[3]||(a[3]=(0,t.eW)("\n      ")),(0,t.Lk)("code",{class:"language-javascript"},(0,r.v_)(s)),a[4]||(a[4]=(0,t.eW)("\n    "))]),a[11]||(a[11]=(0,t.Lk)("h3",null,"-- 測試用例 --",-1)),(0,t.Lk)("pre",{class:"test-block"},[a[5]||(a[5]=(0,t.eW)("      ")),(0,t.Lk)("code",{class:"language-javascript"},(0,r.v_)(d)),a[6]||(a[6]=(0,t.eW)("\n    "))])]))}}),x=i(6262);const k=(0,x.A)(c,[["__scopeId","data-v-55f1518b"]]);var v=k}}]);
//# sourceMappingURL=347.9f947ab8.js.map