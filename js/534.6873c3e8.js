"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[534],{3534:function(n,e,t){t.r(e),t.d(e,{default:function(){return b}});var r=t(641),a=t(33),l=t(953),o=t(8848),i=t.n(o);const c={class:"problem-detail"},s={key:0},u={class:"code-block"},m="\n/*\n  Method 1: Iterative Approach (Declarative)\n  Time complexity: O(log n)\n  Space complexity: O(1)\n*/\nfunction binarySearch(nums: number[], target: number): number {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        // const mid = Math.floor((left + right) / 2);\n        const mid = ~~((left + right) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1; // Target not found\n}\n\n/*\n  Method 2 (Functional Programming)\n  Time complexity: O(log n)\n  Space complexity: O(log n) (due to recursion stack)\n*/\nfunction binarySearchFP(nums: number[], target: number, left: number = 0, right: number = nums.length - 1): number {\n    // Base case: if the range is invalid, the target is not found\n    if (left > right) {\n        return -1;\n    }\n\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] === target) {\n        return mid;\n    } else if (nums[mid] < target) {\n        return binarySearchFP(nums, target, mid + 1, right);\n    } else {\n        return binarySearchFP(nums, target, left, mid - 1);\n    }\n}\n",g="\nconst nums = [-1, 0, 3, 5, 9, 12];\nconst target = 9;\nconsole.log(binarySearch(nums, target)); // Output: 4\n\n// Functional Programming version\nconst nums = [-1, 0, 3, 5, 9, 12];\nconst target = 9;\nconsole.log(binarySearchFP(nums, target)); // Output: 4";var h=(0,r.pM)({__name:"BinarySearch",setup(n){(0,r.sV)((()=>{i().highlightAll()}));const e=(0,l.KR)(!1),t=(0,l.KR)("Copy"),o=()=>{e.value=!e.value},h=async()=>{try{await navigator.clipboard.writeText(m),t.value="Copied!",setTimeout((()=>{t.value="Copy"}),1500)}catch(n){console.error("Failed to copy: ",n)}};return(n,l)=>((0,r.uX)(),(0,r.CE)("div",c,[(0,r.Lk)("button",{class:"close-btn",onClick:l[0]||(l[0]=e=>n.$emit("close"))},"×"),l[7]||(l[7]=(0,r.Lk)("h2",null,"704_Binary Search",-1)),l[8]||(l[8]=(0,r.Lk)("a",{href:"https://leetcode.com/problems/binary-search/description/",target:"_blank"}," leetcode_704 ",-1)),l[9]||(l[9]=(0,r.Lk)("p",null,[(0,r.Lk)("strong",null,"問題:"),(0,r.eW)(" 給定一個已按升序排序的整數數組 nums 和一個整數 target，請寫一個函數在 nums 中搜尋 target。 ")],-1)),e.value?((0,r.uX)(),(0,r.CE)("div",s,l[1]||(l[1]=[(0,r.Lk)("p",null," 如果 target 存在，則返回其索引，否則返回 -1。 必須設計一個具有 O(log n) 時間複雜度的演算法。 ",-1)]))):(0,r.Q3)("",!0),(0,r.Lk)("button",{id:"toggleShowMoreButton",onClick:o},(0,a.v_)(e.value?"(Hide)":"Click to Show More ↓"),1),l[10]||(l[10]=(0,r.Lk)("h3",null,"-- 我的解答 --",-1)),(0,r.Lk)("pre",u,[l[2]||(l[2]=(0,r.eW)("      ")),(0,r.Lk)("button",{class:"copy-btn",onClick:h},(0,a.v_)(t.value),1),l[3]||(l[3]=(0,r.eW)("\n      ")),(0,r.Lk)("code",{class:"language-javascript"},(0,a.v_)(m)),l[4]||(l[4]=(0,r.eW)("\n    "))]),l[11]||(l[11]=(0,r.Lk)("h3",null,"-- 測試用例 --",-1)),(0,r.Lk)("pre",{class:"test-block"},[l[5]||(l[5]=(0,r.eW)("      ")),(0,r.Lk)("code",{class:"language-javascript"},(0,a.v_)(g)),l[6]||(l[6]=(0,r.eW)("\n    "))])]))}}),d=t(6262);const p=(0,d.A)(h,[["__scopeId","data-v-7ba943c0"]]);var b=p}}]);
//# sourceMappingURL=534.6873c3e8.js.map