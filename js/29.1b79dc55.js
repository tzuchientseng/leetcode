"use strict";(self["webpackChunkleetcode"]=self["webpackChunkleetcode"]||[]).push([[29],{6029:function(n,e,i){i.r(e),i.d(e,{default:function(){return v}});var o=i(641),t=i(33),c=i(953),u=i(8848),l=i.n(u);const r={class:"problem-detail"},a={key:0},d={class:"code-block"},m="\n/* ------------------------------------------ GCD (Greatest Common Divisor) ------------------------------------------ */\n/*\nğŸ’¡Concept: GCD(a, b) = GCD(b, a % b)\n  Method 1\n  Time complexity: O(log(min(a, b))) // æ­å¹¾é‡Œå¾—ç®—æ³•çš„*æœ€å·®æƒ…æ³*å‡ºç¾åœ¨å…©å€‹æ•¸æ˜¯é€£çºŒçš„æ–æ³¢é‚£å¥‘æ•¸æ¯æ¬¡è¿­ä»£çš„å•é¡Œè¦æ¨¡ç¸®å°åˆ°åŸä¾†çš„ é»ƒé‡‘æ¯”ä¾‹ç´„ 1.618 å€ e.g: GCD(21, 13)\n  Space complexity: O(1)\n  (a < b): (GCD(18, 48))\n      n = 1; 18 = 48 * 0 + 18 åŠ 18 mod 48\n      n = 2; 48 = 18 * 2 + 12 åŠ 48 mod (18 mod 48) = 12\n      n = 3; 18 = 12 * 1 + 6  åŠ 18 mod 12 = 6\n      n = 4; 12 = 6 * 2 + 0   åŠ 12 mod 6 = 0\n      n = 5;  6 = 0 * 0 + 0   åŠ GCD(18, 48) = 6\n*/\nconst GCD = (dividend: number, divisor: number): number => {\n    dividend = Math.abs(dividend);\n    divisor = Math.abs(divisor);\n\n    while (divisor !== 0) {\n        const remainder = dividend % divisor;\n        dividend = divisor;\n        divisor = remainder;\n    }\n\n    return dividend;\n}\n\n/*\n  Method 2: Functional Programming => Recursion\n  Time complexity: O(log(min(a, b))) \n  Space complexity: O(log(min(a, b))) \n*/\n const gcdRecursive = (dividend: number, divisor: number): number => divisor === 0 ? dividend : gcdRecursive(divisor, dividend % divisor);\n\n/*\n  Mutiple GCD: Functional Programming => Recursion + reduce()\n  Time complexity: O(n*log(m)) \n  Space complexity: O(log(m)) \n\n*/\nconst gcdRecursive = (dividend: number, divisor: number): number => divisor === 0 ? dividend : gcdRecursive(divisor, dividend % divisor);\nconst gcdReduce  = (numbers: number[]): number => numbers.reduce((acc, cur) => gcdRecursive(acc, cur), numbers[0]);\n\n/* ------------------------------------------ LCM (Least Common Multiple) ------------------------------------------ */\n/*\nğŸ’¡Concept: LCM(num1, num2) = Math.abs(num1 * num2) / GCD(num1, num2);\n  Type 1: Computes the Least Common Multiple (LCM) of two numbers\n  Time complexity: O(log(min(a, b)))\n  Space complexity: O(1)\n*/\nconst GCD = (dividend: number, divisor: number): number => {\n    while (divisor !==0 ) {\n        [dividend, divisor] = [divisor, dividend % divisor];\n    }\n    return dividend;\n};\nconst LCM = (num1: number, num2: number): number => Math.abs(num1 * num2) / GCD(num1, num2);\n\n/*\n  Type 2: Computes the Least Common Multiple (LCM) of multiple numbers\n  Time complexity: O(n*log(M)) // where M is the maximum\n  Space complexity: O(1)\n*/\nconst computeMultipleLCM = (numbers: number[]): number => {\n   return  numbers.reduce((acc, cur) => (acc * cur) / GCD(acc, cur) , numbers[0])\n}\n\n/* ------------------------------------------ Others ------------------------------------------ */\n\n/*\n  Advance Method 1: Functional Programming => æŸ¯é‡ŒåŒ– Currying\n  Time complexity: O(log(min(a, b))) // å’Œå‰å…©ç¨®æ–¹æ³•ä¸€æ¨£ï¼Œæ­å¹¾é‡Œå¾—ç®—æ³•çš„æœ€å·®æƒ…æ³æ˜¯é€£çºŒçš„æ–æ³¢é‚£å¥‘æ•¸ã€‚\n  Space complexity: O(log(min(a, b))) // å› ç‚ºéè¿´æ·±åº¦å–æ±ºæ–¼æœ€å°çš„æ•¸å€¼ï¼Œèˆ‡éè¿´ç‰ˆæœ¬ç›¸åŒã€‚\n  Concept:\n    - ä½¿ç”¨æŸ¯é‡ŒåŒ–(Currying)æŠ€è¡“ï¼Œå°‡ GCD å‡½å¼è½‰æ›ç‚ºæ¥å—ä¸€å€‹åƒæ•¸å¾Œï¼Œè¿”å›å¦ä¸€å€‹æ¥å—ç¬¬äºŒå€‹åƒæ•¸çš„å‡½å¼ã€‚\n    - æ¯æ¬¡å‘¼å« gcd(a)(b) æ™‚ï¼Œå°±æœƒè¿”å›ä¸€å€‹æ–°çš„å‡½å¼ç›´åˆ°è¨ˆç®—å®Œæˆã€‚\n    - æ›´å…·å½ˆæ€§ï¼Œå…è¨±éƒ¨åˆ†æ‡‰ç”¨(Partial Application)ï¼Œå¯ä»¥å…ˆå›ºå®šä¸€å€‹åƒæ•¸ï¼Œä¹‹å¾Œå†å‚³å…¥å¦ä¸€å€‹åƒæ•¸ã€‚\n*/\nconst gcd = (a: number) => (b: number): number =>\n    b === 0 ? a : gcd(b)(a % b);\n\n// Test example\nconsole.log(gcd(48)(18)); // Output: 6\n// Partial application example\nconst gcdWith48 = gcd(48); \nconsole.log(gcdWith48(18)); // Output: 6\nconsole.log(gcdWith48(24)); // Output: 24\n\n/*\n  Advance Method 2: Functional Programming with Tail Call Optimization (TCO)\n  Time complexity: O(log(min(a, b))) \n  Space complexity: O(1) // With TCO, the stack usage remains constant.\n*/\nconst gcd = (a: number) => (b: number): number => {\n    // Inner function using tail-recursive optimization\n    const gcdTailRec = (x: number, y: number): number =>\n        y === 0 ? x : gcdTailRec(y, x % y);\n    return gcdTailRec(a, b);\n};\n\n// Test examples\nconsole.log(gcd(48)(18)); // Output: 6\nconsole.log(gcd(56)(98)); // Output: 14\n// Partial application example\nconst gcdWith56 = gcd(56);\nconsole.log(gcdWith56(98)); // Output: 14\nconsole.log(gcdWith56(28)); // Output: 28\n",s="\nconsole.log(GCD(18, 48)); // Output: 6\nconsole.log(gcdRecursive(18, 48)); // Output: 6\nconsole.log(gcdMultiple([48, 18, 30])); // Output: 6\n\nconsole.log(LCM(18, 48)); // Output: 144\nconsole.log(computeMultipleLCM([12, 18, 24]));";var p=(0,o.pM)({__name:"EuclideanAlgorithm",setup(n){(0,o.sV)((()=>{l().highlightAll()}));const e=(0,c.KR)(!1),i=(0,c.KR)("Copy"),u=()=>{e.value=!e.value},p=async()=>{try{await navigator.clipboard.writeText(m),i.value="Copied!",setTimeout((()=>{i.value="Copy"}),1500)}catch(n){console.error("Failed to copy: ",n)}};return(n,c)=>((0,o.uX)(),(0,o.CE)("div",r,[(0,o.Lk)("button",{class:"close-btn",onClick:c[0]||(c[0]=e=>n.$emit("close"))},"Ã—"),c[7]||(c[7]=(0,o.Lk)("h2",null,"Euclidean Algorithm",-1)),c[8]||(c[8]=(0,o.Lk)("a",{href:"https://en.wikipedia.org/wiki/Euclidean_algorithm",target:"_blank"}," wiki - Euclidean_algorithm ",-1)),c[9]||(c[9]=(0,o.Lk)("p",null,[(0,o.Lk)("strong",null,"å•é¡Œ:"),(0,o.eW)(" æ’°å¯«ä¸€å€‹å‡½å¼ä¾†è¨ˆç®—å…©å€‹æ­£æ•´æ•¸æœ€å¤§å…¬å› æ•¸ ")],-1)),e.value?((0,o.uX)(),(0,o.CE)("div",a,c[1]||(c[1]=[(0,o.Lk)("p",null," æ­å¹¾é‡Œå¾—ç®—æ³•åŸç†æ˜¯åè¦†åœ°ç”¨è¼ƒå¤§æ•¸é™¤ä»¥è¼ƒå°æ•¸ï¼Œç›´åˆ°é¤˜æ•¸ç‚º 0ï¼Œç•¶é¤˜æ•¸ç‚º 0 æ™‚ï¼Œç•¶å‰çš„é™¤æ•¸å°±æ˜¯é€™å…©å€‹æ•¸çš„æœ€å¤§å…¬å› æ•¸ã€‚ ",-1),(0,o.eW)(" äº¦å³: GCD(a, b) = GCD(b, a % b)ã€‚ç•¶é™¤æ•¸ç­‰æ–¼é›¶æ™‚ï¼Œè¢«é™¤æ•¸ç‚ºæœ€å¤§å…¬å› æ•¸ã€‚ ")]))):(0,o.Q3)("",!0),(0,o.Lk)("button",{id:"toggleShowMoreButton",onClick:u},(0,t.v_)(e.value?"(Hide)":"Click to Show More â†“"),1),c[10]||(c[10]=(0,o.Lk)("h3",null,"-- æˆ‘çš„è§£ç­” --",-1)),(0,o.Lk)("pre",d,[c[2]||(c[2]=(0,o.eW)("      ")),(0,o.Lk)("button",{class:"copy-btn",onClick:p},(0,t.v_)(i.value),1),c[3]||(c[3]=(0,o.eW)("\n      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,t.v_)(m)),c[4]||(c[4]=(0,o.eW)("\n    "))]),c[11]||(c[11]=(0,o.Lk)("h3",null,"-- æ¸¬è©¦ç”¨ä¾‹ --",-1)),(0,o.Lk)("pre",{class:"test-block"},[c[5]||(c[5]=(0,o.eW)("      ")),(0,o.Lk)("code",{class:"language-javascript"},(0,t.v_)(s)),c[6]||(c[6]=(0,o.eW)("\n    "))])]))}}),g=i(6262);const b=(0,g.A)(p,[["__scopeId","data-v-a72f515e"]]);var v=b}}]);
//# sourceMappingURL=29.1b79dc55.js.map